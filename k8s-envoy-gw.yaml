apiVersion: gateway.networking.k8s.io/v1
kind: GatewayClass
metadata:
  name: eg
spec:
  controllerName: gateway.envoyproxy.io/gatewayclass-controller
---
apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata:
  name: eg
  namespace: default
spec:
  gatewayClassName: eg
  listeners:
    - name: http
      protocol: HTTP
      port: 9090
---
apiVersion: gateway.envoyproxy.io/v1alpha1
kind: SecurityPolicy
metadata:
  name: ext-auth-policy
  namespace: default
spec:
  targetRef:
    group: gateway.networking.k8s.io
    kind: Gateway
    name: eg
  extAuth:
    grpc:
      backendRef:
        group: ""
        kind: Service
        name: ext-authz-opa-service
        namespace: default
        port: 9002
# ---
# apiVersion: gateway.envoyproxy.io/v1alpha1
# kind: SecurityPolicy
# metadata:
#   name: ext-auth-policy2
#   namespace: default
# spec:
#   targetRef:
#     group: gateway.networking.k8s.io
#     kind: Gateway
#     name: eg
#   extAuth:
#     http:
#       backendRef:
#         group: ""
#         kind: Service
#         name: ext-authz-http-service
#         namespace: default
#         port: 5000
#       path: ""
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ext-authz-opa
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ext-authz-opa
  template:
    metadata:
      labels:
        app: ext-authz-opa
    spec:
      containers:
        - name: ext-authz-opa
          image: openpolicyagent/opa:latest-envoy
          args:
            - "run"
            - /data/data.json
            - --server
            - --log-format=json-pretty
            - --set=plugins.envoy_ext_authz_grpc.addr=:9002
            - --set=decision_logs.console=true
            - /etc/policy.rego
          resources:
            limits:
              cpu: "0.8"
              memory: "512Mi"
          volumeMounts:
            - name: policy-volume
              mountPath: /etc/policy.rego
              subPath: policy.rego
            - name: data-volume
              mountPath: /data/data.json
              subPath: data.json
      volumes:
        - name: policy-volume
          configMap:
            name: opa-policy-config
        - name: data-volume
          configMap:
            name: data-config
---
apiVersion: v1
kind: Service
metadata:
  name: ext-authz-opa-service
  namespace: default
spec:
  selector:
    app: ext-authz-opa
  ports:
    - protocol: TCP
      port: 9002
      targetPort: 9002
# ---
# apiVersion: apps/v1
# kind: Deployment
# metadata:
#   name: ext-authz-http
#   namespace: default
# spec:
#   replicas: 1
#   selector:
#     matchLabels:
#       app: ext-authz-http
#   template:
#     metadata:
#       labels:
#         app: ext-authz-http
#     spec:
#       containers:
#         - name: ext-authz-http
#           image: emiljacero/pyauth:dev
#           ports:
#             - containerPort: 5000
#           resources:
#             limits:
#               cpu: "0.5"
#               memory: "256Mi"
#           volumeMounts:
#             - name: data-volume
#               mountPath: /etc/data.json
#               subPath: data.json
#       volumes:
#         - name: data-volume
#           configMap:
#             name: data-config
# ---
# apiVersion: v1
# kind: Service
# metadata:
#   name: ext-authz-http-service
#   namespace: default
# spec:
#   selector:
#     app: ext-authz-http
#   ports:
#     - protocol: TCP
#       port: 5000
#       targetPort: 5000
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-policy-config
  namespace: default
data:
  policy.rego: |
    package envoy.authz

    import rego.v1

    import data.users

    default allow := false

    default headers := {}

    # Function to parse the Basic Auth header and extract the username
    basic_auth_user := user if {
      [_, payload] := split(input.attributes.request.http.headers.authorization, " ")
      decoded := base64url.decode(payload)
      [user, _] := split(decoded, ":")
    }

    allow if {
      user := basic_auth_user
      is_user_valid[user]
    }

    # Validate user by matching extracted user with the namespace in the path
    is_user_valid[user] if {
      user := basic_auth_user
        path := split(input.attributes.request.http.path, "/")
      namespace := path[1] # Assume URL format is /<username>/<resource>
      resource := path[2] # Assume URL format is /<username>/<resource>

      # Ensure the extracted user has an entry in the users object
      # and the namespace from URL matches this user
      users[user] != null
      user == namespace  # Check if the user matches the namespace path
        resource in users[user].clusters  # Check if the resource exists in the cluster list
    }

    # Add headers if the request is allowed
    headers := {"X-Resource-Cluster": resource} if {
      allow
      path := split(input.attributes.request.http.path, "/")
      resource := path[2] # Extract the resource part from the path
    }
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: data-config
  namespace: default
data:
  data.json: |
    {
    "users": {
        "user1": {
            "password": "password1",
            "clusters": [
                "webtop1",
                "webtop1a"
            ]
        },
        "user2": {
            "password": "password2",
            "clusters": [
                "webtop2",
                "webtop2a"
            ]
        }
    }
    }
---
apiVersion: gateway.networking.k8s.io/v1beta1
kind: HTTPRoute
metadata:
  name: kode
  namespace: default
spec:
  parentRefs:
    - name: eg
  hostnames:
    - "localhost"
  rules:
    - backendRefs:
        - group: ""
          kind: Service
          name: kode-sample
          port: 8443
          weight: 1
      matches:
        - path:
            type: PathPrefix
            value: /
